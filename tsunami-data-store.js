/**
 * 津波データ永続化・履歴管理システム
 * 実用機能向上のための実装
 */

class TsunamiDataStore {
    constructor() {
        this.config = {
            storagePrefix: 'tsunami_monitor_',
            maxHistoryEntries: 1000,
            maxStorageSize: 5 * 1024 * 1024, // 5MB（ブラウザ制限を考慮した適正値）
            compressionEnabled: true,
            autoCleanup: true,
            backupInterval: 3600000 // 1時間毎にバックアップ
        };
        
        this.storage = {
            current: null,
            history: [],
            alerts: [],
            statistics: {},
            preferences: {}
        };
        
        this.initializeStorage();
    }
    
    /**
     * ストレージ初期化
     */
    initializeStorage() {
        console.log('💾 津波データストレージ初期化');
        
        try {
            // 既存データの読み込み
            this.loadFromLocalStorage();
            
            // 定期バックアップ開始
            this.startPeriodicBackup();
            
            console.log('✅ ストレージ初期化完了');
            
        } catch (error) {
            console.error('❌ ストレージ初期化失敗:', error);
            this.initializeEmptyStorage();
        }
    }
    
    /**
     * 空のストレージ初期化
     */
    initializeEmptyStorage() {
        this.storage = {
            current: null,
            history: [],
            alerts: [],
            statistics: {
                totalAlerts: 0,
                totalUpdates: 0,
                lastActivity: new Date().toISOString(),
                systemStartTime: new Date().toISOString()
            },
            preferences: {
                soundEnabled: true,
                notificationEnabled: true,
                autoArchive: true,
                alertThreshold: 'advisory'
            }
        };
        
        this.saveToLocalStorage();
    }
    
    /**
     * 現在の津波データを保存
     */
    saveCurrentTsunamiData(tsunamiData) {
        const timestamp = new Date().toISOString();
        
        const dataEntry = {
            id: this.generateId(),
            timestamp,
            data: tsunamiData,
            metadata: {
                source: tsunamiData.metadata?.source || 'unknown',
                activeRegions: tsunamiData.features?.length || 0,
                highestLevel: this.getHighestTsunamiLevel(tsunamiData),
                isEmergency: this.isEmergencyLevel(tsunamiData)
            }
        };
        
        // 現在データを更新
        this.storage.current = dataEntry;
        
        // 履歴に追加（重要な変化のみ）
        if (this.shouldAddToHistory(dataEntry)) {
            this.addToHistory(dataEntry);
        }
        
        // 統計更新
        this.updateStatistics(dataEntry);
        
        // ストレージに保存
        this.saveToLocalStorage();
        
        console.log(`💾 津波データ保存完了: ${dataEntry.metadata.activeRegions}地域`);
        
        return dataEntry.id;
    }
    
    /**
     * 履歴追加判定
     */
    shouldAddToHistory(newEntry) {
        if (!this.storage.current) return true;
        
        const current = this.storage.current;
        const newData = newEntry.data;
        const currentData = current.data;
        
        // 状態変化があった場合のみ履歴に追加
        return (
            newEntry.metadata.activeRegions !== current.metadata.activeRegions ||
            newEntry.metadata.highestLevel !== current.metadata.highestLevel ||
            newEntry.metadata.isEmergency !== current.metadata.isEmergency
        );
    }
    
    /**
     * 履歴に追加
     */
    addToHistory(dataEntry) {
        this.storage.history.unshift(dataEntry);
        
        // 最大履歴数を超えた場合は古いデータを削除
        if (this.storage.history.length > this.config.maxHistoryEntries) {
            const removed = this.storage.history.splice(this.config.maxHistoryEntries);
            console.log(`🗑️ 古い履歴 ${removed.length} 件を削除`);
        }
    }
    
    /**
     * アラート記録
     */
    recordAlert(alertData) {
        const alertEntry = {
            id: this.generateId(),
            timestamp: new Date().toISOString(),
            type: alertData.type, // 'warning', 'advisory', 'cleared'
            level: alertData.level,
            regions: alertData.regions || [],
            message: alertData.message,
            acknowledged: false,
            autoGenerated: true
        };
        
        this.storage.alerts.unshift(alertEntry);
        
        // アラート統計更新
        this.storage.statistics.totalAlerts++;
        
        // 最大1000件のアラートを保持
        if (this.storage.alerts.length > 1000) {
            this.storage.alerts.splice(1000);
        }
        
        this.saveToLocalStorage();
        
        console.log(`🚨 アラート記録: ${alertEntry.type} - ${alertEntry.message}`);
        
        return alertEntry.id;
    }
    
    /**
     * 履歴取得
     */
    getHistory(options = {}) {
        const {
            limit = 50,
            startDate = null,
            endDate = null,
            levelFilter = null,
            emergencyOnly = false
        } = options;
        
        let filtered = [...this.storage.history];
        
        // 日付フィルター
        if (startDate) {
            filtered = filtered.filter(entry => new Date(entry.timestamp) >= new Date(startDate));
        }
        
        if (endDate) {
            filtered = filtered.filter(entry => new Date(entry.timestamp) <= new Date(endDate));
        }
        
        // レベルフィルター
        if (levelFilter) {
            filtered = filtered.filter(entry => entry.metadata.highestLevel === levelFilter);
        }
        
        // 緊急時のみフィルター
        if (emergencyOnly) {
            filtered = filtered.filter(entry => entry.metadata.isEmergency);
        }
        
        return filtered.slice(0, limit);
    }
    
    /**
     * アラート履歴取得
     */
    getAlerts(options = {}) {
        const {
            limit = 100,
            unacknowledgedOnly = false,
            type = null
        } = options;
        
        let filtered = [...this.storage.alerts];
        
        if (unacknowledgedOnly) {
            filtered = filtered.filter(alert => !alert.acknowledged);
        }
        
        if (type) {
            filtered = filtered.filter(alert => alert.type === type);
        }
        
        return filtered.slice(0, limit);
    }
    
    /**
     * アラート確認済みマーク
     */
    acknowledgeAlert(alertId) {
        const alert = this.storage.alerts.find(a => a.id === alertId);
        if (alert) {
            alert.acknowledged = true;
            alert.acknowledgedAt = new Date().toISOString();
            this.saveToLocalStorage();
            
            console.log(`✅ アラート確認: ${alertId}`);
            return true;
        }
        return false;
    }
    
    /**
     * 統計情報更新
     */
    updateStatistics(dataEntry) {
        this.storage.statistics.totalUpdates++;
        this.storage.statistics.lastActivity = dataEntry.timestamp;
        
        // 時間別統計
        const hour = new Date(dataEntry.timestamp).getHours();
        if (!this.storage.statistics.hourlyActivity) {
            this.storage.statistics.hourlyActivity = {};
        }
        this.storage.statistics.hourlyActivity[hour] = (this.storage.statistics.hourlyActivity[hour] || 0) + 1;
        
        // レベル別統計
        if (!this.storage.statistics.levelCounts) {
            this.storage.statistics.levelCounts = {};
        }
        const level = dataEntry.metadata.highestLevel;
        if (level) {
            this.storage.statistics.levelCounts[level] = (this.storage.statistics.levelCounts[level] || 0) + 1;
        }
    }
    
    /**
     * 最高津波レベル取得
     */
    getHighestTsunamiLevel(tsunamiData) {
        if (!tsunamiData.features || tsunamiData.features.length === 0) {
            return 'none';
        }
        
        const levelPriority = {
            'major_warning': 4,
            'warning': 3,
            'advisory': 2,
            'forecast': 1,
            'cleared': 0,
            'none': 0
        };
        
        let highestLevel = 'none';
        let highestPriority = -1;
        
        tsunamiData.features.forEach(feature => {
            const level = feature.properties.STATUS;
            const priority = levelPriority[level] || 0;
            
            if (priority > highestPriority) {
                highestLevel = level;
                highestPriority = priority;
            }
        });
        
        return highestLevel;
    }
    
    /**
     * 緊急レベル判定
     */
    isEmergencyLevel(tsunamiData) {
        const highestLevel = this.getHighestTsunamiLevel(tsunamiData);
        return ['major_warning', 'warning'].includes(highestLevel);
    }
    
    /**
     * LocalStorageに保存
     */
    saveToLocalStorage() {
        try {
            const serialized = JSON.stringify(this.storage);
            
            // ストレージサイズチェック
            if (serialized.length > this.config.maxStorageSize) {
                console.warn('⚠️ ストレージサイズ上限に到達 - クリーンアップ実行');
                this.performCleanup();
                return this.saveToLocalStorage(); // 再試行
            }
            
            localStorage.setItem(this.config.storagePrefix + 'data', serialized);
            localStorage.setItem(this.config.storagePrefix + 'lastSave', new Date().toISOString());
            
        } catch (error) {
            console.error('❌ LocalStorage保存失敗:', error);
            
            if (error.name === 'QuotaExceededError') {
                console.log('💾 ストレージ容量不足 - 緊急クリーンアップ実行');
                this.emergencyCleanup();
            }
        }
    }
    
    /**
     * LocalStorageから読み込み
     */
    loadFromLocalStorage() {
        try {
            const data = localStorage.getItem(this.config.storagePrefix + 'data');
            
            if (data) {
                this.storage = JSON.parse(data);
                console.log(`📖 ストレージから ${this.storage.history.length} 件の履歴を読み込み`);
            } else {
                this.initializeEmptyStorage();
            }
            
        } catch (error) {
            console.error('❌ LocalStorage読み込み失敗:', error);
            this.initializeEmptyStorage();
        }
    }
    
    /**
     * クリーンアップ実行
     */
    performCleanup() {
        // 古い履歴を削除
        const oldHistoryCount = this.storage.history.length;
        this.storage.history = this.storage.history.slice(0, Math.floor(this.config.maxHistoryEntries * 0.7));
        
        // 古いアラートを削除
        const oldAlertCount = this.storage.alerts.length;
        this.storage.alerts = this.storage.alerts.slice(0, 500);
        
        console.log(`🧹 クリーンアップ完了: 履歴 ${oldHistoryCount - this.storage.history.length} 件、アラート ${oldAlertCount - this.storage.alerts.length} 件を削除`);
    }
    
    /**
     * 緊急クリーンアップ
     */
    emergencyCleanup() {
        // 履歴とアラートを大幅削減
        this.storage.history = this.storage.history.slice(0, 100);
        this.storage.alerts = this.storage.alerts.slice(0, 50);
        
        // 時間別統計をリセット
        delete this.storage.statistics.hourlyActivity;
        
        console.log('🚨 緊急クリーンアップ完了');
    }
    
    /**
     * 定期バックアップ開始
     */
    startPeriodicBackup() {
        setInterval(() => {
            this.createBackup();
        }, this.config.backupInterval);
    }
    
    /**
     * バックアップ作成
     */
    createBackup() {
        try {
            const backup = {
                timestamp: new Date().toISOString(),
                version: '1.0',
                data: this.storage
            };
            
            const compressed = JSON.stringify(backup);
            localStorage.setItem(this.config.storagePrefix + 'backup', compressed);
            
            console.log('💾 バックアップ作成完了');
            
        } catch (error) {
            console.error('❌ バックアップ作成失敗:', error);
        }
    }
    
    /**
     * 統計情報取得
     */
    getStatistics() {
        return {
            ...this.storage.statistics,
            historyCount: this.storage.history.length,
            alertCount: this.storage.alerts.length,
            unacknowledgedAlerts: this.storage.alerts.filter(a => !a.acknowledged).length,
            storageSize: JSON.stringify(this.storage).length
        };
    }
    
    /**
     * 設定更新
     */
    updatePreferences(newPreferences) {
        this.storage.preferences = { ...this.storage.preferences, ...newPreferences };
        this.saveToLocalStorage();
        
        console.log('⚙️ 設定更新完了');
    }
    
    /**
     * 設定取得
     */
    getPreferences() {
        return { ...this.storage.preferences };
    }
    
    /**
     * ユニークID生成
     */
    generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }
    
    /**
     * エクスポート機能
     */
    exportData(format = 'json') {
        const exportData = {
            exportTime: new Date().toISOString(),
            version: '1.0',
            format,
            data: this.storage
        };
        
        if (format === 'json') {
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `tsunami_data_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            
            URL.revokeObjectURL(url);
            
            console.log('📁 データエクスポート完了');
        }
    }
    
    /**
     * データクリア
     */
    clearAllData() {
        const confirmed = confirm('全ての津波監視データを削除しますか？この操作は取り消せません。');
        
        if (confirmed) {
            localStorage.removeItem(this.config.storagePrefix + 'data');
            localStorage.removeItem(this.config.storagePrefix + 'backup');
            localStorage.removeItem(this.config.storagePrefix + 'lastSave');
            
            this.initializeEmptyStorage();
            
            console.log('🗑️ 全データクリア完了');
            return true;
        }
        
        return false;
    }
}

// グローバル公開
if (typeof window !== 'undefined') {
    window.TsunamiDataStore = TsunamiDataStore;
}

// Node.js環境対応
if (typeof module !== 'undefined' && module.exports) {
    module.exports = TsunamiDataStore;
}

console.log('💾 津波データストレージシステム準備完了');